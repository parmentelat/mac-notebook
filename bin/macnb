#!/bin/bash
# -*- shell-script -*-

#
# opening notebooks from the finder, or the command line
#
# . runs notebook server when needed
# . can be used to list or kill that process
# . when used in virtualenv mode, is able to find most suitable
#   virtualenv by walking up the notebook path and looking
#   for a directory named 'venv'
# . will export JUPYTER_CONFIG_DIR to venv/dot-jupyter
#   if that can be found
#

COMMAND=$(basename $0)
ROOT=$HOME
# some regexp to find virtualenvs
VENV_PATTERN="venv"
# stands for housekeeping
HKP=$ROOT/.macnb


#################### helpers
# turn on with -v
VERBOSE=
ACTION=open

function echo-stderr() {
    echo >&2 "$@"
}

function verbose() {
    [ -z "$VERBOSE" ] && return
    echo-stderr "$@"
}


function set-root() {
    local newroot="$1"
    ROOT=$newroot
    verbose "Using as ROOT $ROOT"
    HKP=$ROOT/.macnb
    [ -d $HKP ] || mkdir $HKP
}


function get-free-port() {
    python3 << EOF
import socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind(('', 0))
addr = s.getsockname()
print(addr[1])
s.close()
EOF
}


function relative-path() {
    path=$1; shift
    local abs_root=$(cd $ROOT; pwd -P)
    if [ -d $path ]; then
        local abs_path=$(cd $path; pwd -P)
    else
        local filename=$(basename $path)
        local abs_file_dir=$(cd $(dirname $path); pwd -P)
        local abs_path=$abs_file_dir/$filename
    fi
    echo $abs_path | sed -e "s,$abs_root,,"
}


####################
function locate-root() {
    # open mode will pass us notebook paths
    # other functions don't pass us anything
    local wherefrom=$1; shift
    [ -z "$wherefrom" ] && wherefrom=$(pwd -P)
    [ -d "$wherefrom" ] || wherefrom=$(dirname $wherefrom)
    [ -d "$wherefrom" ] || { echo-stderr "can't locate root from $wherefrom"; exit 1;}

    # where to stop
    local canonical_home=$(cd; pwd -P)
    pushd $wherefrom >& /dev/null
    while true; do
        local here=$(pwd -P)
        # check if we can find a virtualenv
        ls -d $here/${VENV_PATTERN}/bin/activate >& /dev/null
        if [ "$?" == "0" ] ; then
            local activator=$(ls $here/${VENV_PATTERN}/bin/activate | head -1)
            local venvdir=$(dirname $(dirname $activator))
            if [ ! -f $venvdir/bin/jupyter ]; then
                echo-stderr "Warning: ignoring virtualenv $venvdir that has no jupyter installed"
                cd ..
                continue
            fi
            source $activator
            verbose "Running in virtual env $activator"
            topdir=$(dirname $venvdir)
            set-root $topdir
            break
        elif [ "$here" == "$canonical_home" ]; then
            verbose "Deactivating just in case"
            deactivate >& /dev/null
            set-root $here
            break
        elif [ "$here" == "/" ]; then
            >&2 echo "you're not under your home directory - exiting"; exit 1
        else
            cd ..
        fi
    done
    popd >& /dev/null
}

####################
function list-all-jupyters() {
    echo "============================== "
    local tmpjson=/tmp/$$.json
    jupyter notebook list --json > $tmpjson
    python3 << EOF
import json
with open("$tmpjson") as feed:
    records = [json.loads(line) for line in feed]
if not records:
    print("No jupyter notebook server running")
else:
    for record in records:
        print(f"{record['notebook_dir']}: pid={record['pid']} - port={record['pid']}")
EOF
    echo "============================== "
    pids=$(pgrep -f jupyter)
    [ -n "$pids" ] && ps $pids
}

####################
# return 0 if false (cannot find)
# or 1 if true (the pid as recorded in our pid file is up and running)
function running-jupyter() {
    verbose "running-jupyter"
    local recorded_pid=$(cat $HKP/pid 2> /dev/null)
    # return false if not found
    [ -z "$recorded_pid" ] && return 1
    # return false if process is not alive
    ps $recorded_pid >& /dev/null || return 1
    # return false if pid not found among meaningful processes
    pgrep -f jupyter-notebook | grep --silent '^'"${recorded_pid}"'$' || return 1
    return 0
}


global_options="--NotebookApp.iopub_data_rate_limit=10000000000"

# does not check for another running instance
function start-jupyter() {
    cd $ROOT
    verbose "Starting jupyter in $(pwd)"
    verbose "start-jupyter"
    local token=$(echo $RANDOM-$RANDOM)
    local port=$(get-free-port)
    verbose "Using free port $port"
    local command="nohup jupyter notebook --port $port --no-browser --NotebookApp.token=\"$token\" $global_options"
    verbose "starting $command"
    $command < /dev/null 2> $HKP/log &
    echo $! > $HKP/pid
    echo $token > $HKP/token
    echo $port > $HKP/port
    cd - >& /dev/null
}


function running-or-start-jupyter() {
    running-jupyter || start-jupyter
}


function kill-jupyter() {
    local notebook
    for notebook in "$@"; do
        locate-root $notebook
        verbose "kill-jupyter"
        local recorded_pid=$(cat $HKP/pid 2> /dev/null)
        # return false if not found
        [ -z "$recorded_pid" ] && { verbose "pid not found from $HKP/pid" ; return 1; }
        verbose "killing pid $pid"
        kill $recorded_pid
        rm $HKP/pid $HKP/port $HKP/token
    done
}

function list-jupyter() {
    local notebook
    for notebook in "$@"; do
        locate-root $notebook
        verbose "for $notebook: listing in $ROOT"
        local pid=$(cat $HKP/pid 2> /dev/null)
        if [ -z "$pid" ]; then
            echo "No jupyter running in dir $ROOT"
        else
            ps $pid
        fi
    done
}

function open-notebooks() {
    local notebook
    for notebook in "$@"; do
        verbose dealing with notebook $notebook
        local path=""
        local _path; for _path in "$notebook".ipynb "$notebook"; do
            verbose "Trying file $_path"
            [ -e $_path ] && { path=$_path; break; }
            verbose nope
        done
        if [ -z "$path" ]; then
            echo "Cannot spot notebook $notebook - ignored" >& 2
            continue
        fi
        verbose path=$path

        [ -n "venv_mode" ] && locate-root $path
        # when using virtual envs, we may have to talk to
        # several jupyter servers
        running-or-start-jupyter
        local port=$(cat $HKP/port)
        local token=$(cat $HKP/token)
        verbose server started

        local url
        if [ -d "$path" ]; then
            url="http://localhost:$port/tree$(relative-path $path)"
        else
            url="http://localhost:$port/notebooks$(relative-path $path)"
        fi
        url="$url?token=$token"
        verbose "opening url $url"
        open $url
    done
}

USAGE="Usage: $COMMAND [options] [-l] [-a] [-k]
   or: $COMMAND [options] [notebooks or dirs]
Modes:
  -l: list running jupyter in this dir (default if commmand contains 'list')
  -a: list all running jupyters (default if command contains 'all')
  -k: kill jupyter (default if command contains 'kill')
  otherwise: open notebook(s) or directory in browser
Options:
  -e: use virtualenvs as found along path searching for $VENV_PATTERN
      (default if command contains 'venv')
  -r root: select an alternative root (default is $HOME)
"

function main() {
    while getopts "klaer:v" opt; do
        case $opt in
            k) ACTION=kill;;
            l) ACTION=list;;
            a) ACTION=list_all;;
            e) venv_mode=true;;
            r) option_root=$OPTARG;;
            v) VERBOSE=true;;
            \?) >&2 printf "$USAGE" ; exit 1;;
        esac
    done
    shift $(($OPTIND - 1))

    # compute ROOT according to context and options
    if [ -n "venv_mode" ] ; then
        locate-root
    elif [ -n "option_root"]; then
        set-root $option_root
    else
        set-root $HOME
    fi

    verbose "Managing jupyter server in $ROOT"

    local args
    if [[ -z "$@" ]]; then
        args="."
    else
        args="$@"
    fi

    case "$ACTION" in
        list_all) list-all-jupyters;;
        kill) kill-jupyter $args;;
        list) list-jupyter $args;;
        *) open-notebooks  $args;;
    esac
}

# get implicit options from the command name - allows to use symlinks
[[ "$COMMAND" =~ .*kill.* ]] && ACTION=kill
[[ "$COMMAND" =~ .*list.* ]] && ACTION=list
[[ "$COMMAND" =~ .*all.* ]] && ACTION=list_all
[[ "$COMMAND" =~ .*venv.* ]] && venv_mode=true

main "$@"
